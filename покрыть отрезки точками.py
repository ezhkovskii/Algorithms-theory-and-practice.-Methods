'''
Покрыть отрезки точками.
По данным n отрезкам необходимо найти множество точек минимального размера, для которого каждый из отрезков содержит хотя бы одну из точек.
В первой строке дано число 1≤n≤100 отрезков.
Каждая из последующих n  строк содержит по два числа 0≤l≤r≤10^9 задающих начало и конец отрезка.
Выведите оптимальное число m точек и сами m точек.
Если таких множеств точек несколько, выведите любое из них.
'''

class Tochka:
    def __init__(self, num, storona_otrezka, coordinata):
        self.num = num              #номер отрезка
        self.s = storona_otrezka    #сторона отрезка (левая или правая)
        self.c = coordinata         #координата

'''
Сортировка координат отрезков.
В каждой точке хранится номер отрезка, координата и сторона(левым или правым).
Сортировка происходит так:  если есть несколько точек с одной координатой, то сначала будут идти левые концы, и только потом - правые.
'''
def sort_t(tochki):
    n = len(tochki)
    i = 0
    t = True
    while(t):
        t = False
        for j in range(n-i-1):
            if (tochki[j].c > tochki[j+1].c) or ((tochki[j].c == tochki[j+1].c) and (tochki[j].s > tochki[j+1].s)):
                tochki[j], tochki[j+1] = tochki[j+1], tochki[j]
                t = True
        i = i + 1
    return tochki

'''
Заведём стек, в котором будут храниться номера отрезков, рассматриваемых в данный момент; изначально стек пуст.
Двигаемся в сортированном порядке.
Если текущая точка - левый конец, то просто добавляем номер её отрезка в стек.
Если же она является правым концом, то проверяем, не был ли покрыт этот отрезок.
Если он уже был покрыт, то ничего не делаем и переходим к следующей точке.
Если же он ещё не был покрыт, то мы добавляем текущую точку в ответ, и теперь мы хотим отметить для всех текущих отрезков, что они становятся покрытыми.
По окончании работы алгоритма все отрезки будут покрыты, и притом наименьшим числом точек.
'''
def process(sort_tochki):
    stek = {}   #отрезки
    otvet = []
    for i in sort_tochki:
        if i.s == 0: #если левый край, то добавляем отрезок точки в список непокрытых
            stek[i.num] = False
        elif(stek[i.num] == False):       #если правый край и если отрезок не покрыт, то добавляем данную точку в ответ и покрываем все отрезки в стеке
            otvet.append(i)
            for k, v in stek.items():
                stek[k] = True
    return otvet
    
def main():
    n = int(input())    #кол. отрезков
    tochki = []
    for i in range(n):  #добавления номера, стороны и координаты в список
        l, r = map(int, input().split())
        tochki.append(Tochka(i, 0, l)) #0 = левая
        tochki.append(Tochka(i, 1, r)) #1 = правая
    sort_tochki = sort_t(tochki.copy())
    otvet = process(sort_tochki)
    print(len(otvet))
    for i in otvet:
        print(i.c, end = ' ')

if __name__ == "__main__":
    main()
